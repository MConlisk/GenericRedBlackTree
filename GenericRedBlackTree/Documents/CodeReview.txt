Code Review by zzzcode.ai
Using a Direct Tone
https://zzzcode.ai/code-review?id=22479d62-f683-4141-bdb4-8f720131bdfa

Code:
namespace RedBlackTree.Trees
{

	/// <summary>
	/// This is a Red-Black Tree with a Generic value type.
	/// additionally, an integer type as a key 
	/// </summary>
	/// <typeparam name="TValue">The Generic _value Type</typeparam>
	public sealed class GenericRedBlackTree<TValue> : IGenericRedBlackTree<TValue>
	{
		private int _maxSize;
		private GenericRedBlackTreeNode<TValue> _root;

		private HashSet<int> _index = GenericFactoryPool.Create(() => new HashSet<int>());

		/// <summary>
		/// This is a Red-Black Tree with a Generic value type.
		/// additionally, an integer type as a key 
		/// </summary>
		/// <param name="maxSize">The Maximum size this tree is allowed to grow.</param>
		public GenericRedBlackTree(int maxSize)
		{
			if (EqualityComparer<int>.Default.Equals(maxSize, default))
			{
				_maxSize = default;
			}
			else
			{
				if (maxSize < 0)
				{
					_maxSize = 0;
				}
				else
				{
					_maxSize = maxSize;
				}
			}
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="GenericRedBlackTree{TValue}"/> class.
		/// </summary>
		public GenericRedBlackTree() : this(default) { }

		/// <summary>
		/// Gets the set of keys in the Red-Black Tree.
		/// </summary>
		public ReadOnlyCollection<int> Index => new(_index.ToList());

		/// <summary>
		/// Gets or sets the maximum size of the tree. If set to null, there is no maximum size limit.
		/// </summary>
		public int MaxSize
		{
			get => _maxSize;
			set
			{
				if (_maxSize == default) _maxSize = value;
			}
		}

		/// <summary>
		/// Checks if the Red-Black Tree contains a specific key.
		/// </summary>
		/// <param name="id">The key to check for.</param>
		/// <returns>True if the key is present in the tree; otherwise, false.</returns>
		public bool Contains(int id) => _index.Contains(id);

		/// <summary>
		/// Gets the number of elements in the Red-Black Tree.
		/// </summary>
		public int Count { get => _index.Count; }

		/// <summary>
		/// Inserts a new key-value pair into the Red-Black Tree.
		/// </summary>
		/// <param name="key">The key to insert.</param>
		/// <param name="value">The value associated with the key.</param>
		public void Insert(int key, TValue value)
		{
			ArgumentNullException.ThrowIfNull(value);
			if (key < 0) throw new ArgumentException($"Invalid Key:{key}, the key must be a positive integer.");
			if (_index.Count == _maxSize && _maxSize > 0) throw new InvalidOperationException($"The maximum size of the tree has been reached, Remove entries before attempting to add more.");

			if (_index.Add(key))
			{
				var nodeToInsert = GenericFactoryPool.Create(() => new GenericRedBlackTreeNode<TValue>(key, value));

				if (_root == null)
				{
					_root = nodeToInsert;
					_root.IsRed = false;
				}
				else if (_root.Left == null)
				{
					_root.Left = nodeToInsert;
				}
				else if (_root.Right == null)
				{
					_root.Right = nodeToInsert;
				}
				else
				{
					InsertLeaf(_root, nodeToInsert);
				}
				return;
			}
			throw new DuplicateNameException($"{key}");
		}

		/// <summary>
		/// Inserts a new leaf node into the Red-Black Tree.
		/// </summary>
		/// <param name="currentNode">The current node to start the insertion from.</param>
		/// <param name="nodeToInsert">The new node to insert as a leaf.</param>
		private void InsertLeaf(GenericRedBlackTreeNode<TValue> currentNode, GenericRedBlackTreeNode<TValue> nodeToInsert)
		{
			ArgumentNullException.ThrowIfNull(currentNode);
			ArgumentNullException.ThrowIfNull(nodeToInsert);

			var queue = GenericFactoryPool.Create(() => new ConcurrentStack<GenericRedBlackTreeNode<TValue>>());
			queue.Push(currentNode);

			while (!queue.IsEmpty)
			{
				queue.TryPop(out GenericRedBlackTreeNode<TValue> parentNode);
				if (parentNode.Left == null)
				{
					parentNode.Left = nodeToInsert;
					nodeToInsert.Parent = parentNode;
					GenericFactoryPool.Recycle(parentNode);
					break;
				}
				else if (parentNode.Right == null)
				{
					parentNode.Right = nodeToInsert;
					nodeToInsert.Parent = parentNode;
					GenericFactoryPool.Recycle(parentNode);
					break;
				}
				else
				{
					queue.Push(parentNode.Left as GenericRedBlackTreeNode<TValue>);
					queue.Push(parentNode.Right as GenericRedBlackTreeNode<TValue>);
					GenericFactoryPool.Recycle(parentNode);
					continue;
				}
				
			}

			if (!nodeToInsert.IsRed) FixInsert(ref nodeToInsert);
			GenericFactoryPool.Recycle(queue);
		}

		/// <summary>
		/// Removes a key-value pair from the Red-Black Tree.
		/// </summary>
		/// <param name="key">The key to remove.</param>
		public void Remove(int key)
		{
			var node = FindNodeContainingKey(_root, key);

			if (!_index.Remove(key) || node == null)
			{
				// Key not found, throw an exception
				throw new KeyNotFoundException($"Unable to find Key:{key} in the tree.");
			}

			var replacementNode = node.Left == null || node.Right == null ? node : Successor(ref node);
			var child = replacementNode.Left ?? replacementNode.Right as GenericRedBlackTreeNode<TValue>;

			ReplaceNode(replacementNode, child as GenericRedBlackTreeNode<TValue>);

			if (replacementNode != node)
			{
				node.Value = replacementNode.Value;
			}

			if (!replacementNode.IsRed)
			{
				GenericRedBlackTreeNode<TValue> childNode = child as GenericRedBlackTreeNode<TValue>;
				FixRemove(ref childNode, replacementNode.Parent as GenericRedBlackTreeNode<TValue>);
			}

			// Recycle of the node after all operations are complete
			GenericFactoryPool.Recycle(node);
		}

		/// <summary>
		/// Replaces a node in the Red-Black Tree with a new node, updating parentNode and child relationships.
		/// </summary>
		/// <param name="replacementNode">The node to be replaced.</param>
		/// <param name="child">The replacement node.</param>
		private void ReplaceNode(GenericRedBlackTreeNode<TValue> replacementNode, GenericRedBlackTreeNode<TValue> child)
		{
			if (child != null)
			{
				child.Parent = replacementNode.Parent;
			}

			if (replacementNode.Parent == null)
			{
				_root = child;
			}
			else if (replacementNode == replacementNode.Parent.Left)
			{
				replacementNode.Parent.Left = child;
			}
			else
			{
				replacementNode.Parent.Right = child;
			}
		}

		/// <summary>
		/// Updates the value associated with a key in the Red-Black Tree.
		/// </summary>
		/// <param name="key">The key to update.</param>
		/// <param name="value">The new value to associate with the key.</param>
		public void Update(int key, TValue value)
		{
			Remove(key);
			Insert(key, value);
		}

		/// <summary>
		/// Gets the value associated with a specific key in the Red-Black Tree.
		/// </summary>
		/// <param name="key">The key to look up.</param>
		/// <returns>The value associated with the key.</returns>
		public TValue GetValue(int key)
		{
			if (!_index.Contains(key)) throw new KeyNotFoundException($"Key:{key} was not found in the index.");

			return FindNodeContainingKey(_root, key).Value;
		}

		/// <summary>
		/// Finds a node in the Red-Black Tree that contains a specific key.
		/// </summary>
		/// <param name="currentNode">The current node to start the search from.</param>
		/// <param name="key">The key to search for.</param>
		/// <returns>The node containing the key, or null if not found.</returns>
		private static GenericRedBlackTreeNode<TValue> FindNodeContainingKey(GenericRedBlackTreeNode<TValue> currentNode, int key)
		{
			ConcurrentQueue<GenericRedBlackTreeNode<TValue>> Queue = new();
			Queue.Enqueue(currentNode);

			while (Queue.TryDequeue(out GenericRedBlackTreeNode<TValue> node))
			{
				if (node.Key == key) return node;

				if (node.Left != null) Queue.Enqueue(node.Left as GenericRedBlackTreeNode<TValue>);
				if (node.Right != null) Queue.Enqueue(node.Right as GenericRedBlackTreeNode<TValue>);
			}

			throw new KeyNotFoundException($"Key:{key} was not found in the Tree.");
		}

		/// <summary>
		/// Finds the minimum node in a given Red-Black Tree.
		/// </summary>
		/// <param name="currentNode">The root node of the tree.</param>
		/// <returns>The minimum node in the tree.</returns>
		private static GenericRedBlackTreeNode<TValue> Minimum(GenericRedBlackTreeNode<TValue> currentNode)
		{
			while (currentNode.Left != null)
				currentNode = (GenericRedBlackTreeNode<TValue>)currentNode.Left;
			return currentNode;
		}

		/// <summary>
		/// Finds the successor node in a given Red-Black Tree.
		/// </summary>
		/// <param name="currentNode">The node to find the successor for.</param>
		/// <returns>The successor node of the given node.</returns>
		private static GenericRedBlackTreeNode<TValue> Successor(ref GenericRedBlackTreeNode<TValue> currentNode)
		{
			if (currentNode.Right != null)
				return Minimum((GenericRedBlackTreeNode<TValue>)currentNode.Right);

			var parentNode = currentNode.Parent;
			while (parentNode != null && currentNode == parentNode.Right)
			{
				currentNode = (GenericRedBlackTreeNode<TValue>)parentNode;
				parentNode = parentNode.Parent;
			}
			return (GenericRedBlackTreeNode<TValue>)parentNode;
		}

		/// <summary>
		/// Fixes the Red-Black Tree after an insert operation to maintain the properties of the tree.
		/// </summary>
		/// <param name="currentNode">The newly inserted node.</param>
		private void FixInsert(ref GenericRedBlackTreeNode<TValue> currentNode)
		{
			ArgumentNullException.ThrowIfNull(currentNode);

			while (IsRed(currentNode.Parent as GenericRedBlackTreeNode<TValue>) && IsRed(currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>))
			{
				if (IsLeftChild(currentNode.Parent as GenericRedBlackTreeNode<TValue>))
				{
					var uncle = GetRightSibling(currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>);

					if (IsRed(uncle))
					{
						// Case 1: Recoloring
						RecolorNodes(currentNode.Parent as GenericRedBlackTreeNode<TValue>, uncle, currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>);
						currentNode = currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>;
					}
					else
					{
						if (IsRightChild(currentNode))
						{
							// Case 2: Left rotation
							currentNode = currentNode.Parent as GenericRedBlackTreeNode<TValue>;
							RotateLeft(currentNode);
						}

						// Case 3: Right rotation
						RecolorNodes(currentNode.Parent as GenericRedBlackTreeNode<TValue>, currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>);
						RotateRight(currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>);
					}
				}
				else
				{
					var uncle = GetLeftSibling(currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>);

					if (IsRed(uncle))
					{
						// Case 1: Recoloring
						RecolorNodes(currentNode.Parent as GenericRedBlackTreeNode<TValue>, uncle, currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>);
						currentNode = currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>;
					}
					else
					{
						if (IsLeftChild(currentNode))
						{
							// Case 2: Right rotation
							currentNode = currentNode.Parent as GenericRedBlackTreeNode<TValue>;
							RotateRight(currentNode);
						}

						// Case 3: Left rotation
						RecolorNodes(currentNode.Parent as GenericRedBlackTreeNode<TValue>, currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>);
						RotateLeft(currentNode.Parent.Parent as GenericRedBlackTreeNode<TValue>);
					}
				}
			}

			_root.IsRed = false;
		}

		/// <summary>
		/// Checks if a given node is red.
		/// </summary>
		/// <param name="currentNode">The node to check.</param>
		/// <returns>True if the node is red; otherwise, false.</returns>
		private static bool IsRed(GenericRedBlackTreeNode<TValue> currentNode) => currentNode != null && currentNode.IsRed;

		/// <summary>
		/// Checks if a given node is the left child of its parentNode.
		/// </summary>
		/// <param name="currentNode">The node to check.</param>
		/// <returns>True if the node is the left child; otherwise, false.</returns>
		private static bool IsLeftChild(GenericRedBlackTreeNode<TValue> currentNode) => currentNode == currentNode.Parent.Left;

		/// <summary>
		/// Checks if a given node is the right child of its parentNode.
		/// </summary>
		/// <param name="currentNode">The node to check.</param>
		/// <returns>True if the node is the right child; otherwise, false.</returns>
		private static bool IsRightChild(GenericRedBlackTreeNode<TValue> currentNode) => currentNode == currentNode.Parent.Right;

		/// <summary>
		/// Gets the left sibling of a given node.
		/// </summary>
		/// <param name="currentNode">The node to find the left sibling for.</param>
		/// <returns>The left sibling of the node.</returns>
		private static GenericRedBlackTreeNode<TValue> GetLeftSibling(GenericRedBlackTreeNode<TValue> currentNode) =>
			(GenericRedBlackTreeNode<TValue>)currentNode.Parent.Left;

		/// <summary>
		/// Gets the right sibling of a given node.
		/// </summary>
		/// <param name="currentNode">The node to find the right sibling for.</param>
		/// <returns>The right sibling of the node.</returns>
		private static GenericRedBlackTreeNode<TValue> GetRightSibling(GenericRedBlackTreeNode<TValue> currentNode) =>
			(GenericRedBlackTreeNode<TValue>)currentNode.Parent.Right;

		/// <summary>
		/// Recolors the given nodes in the Red-Black Tree, toggling their color between red and black.
		/// </summary>
		/// <param name="nodes">The nodes to recolor.</param>
		private static void RecolorNodes(params GenericRedBlackTreeNode<TValue>[] nodes)
		{
			foreach (var n in nodes)
			{
				n.IsRed = !n.IsRed;
			}
		}

		/// <summary>
		/// Fixes the Red-Black Tree after a remove operation to maintain the properties of the tree.
		/// </summary>
		/// <param name="currentNode">The node to fix.</param>
		/// <param name="parentNode">The parentNode of the node.</param>
		private void FixRemove(ref GenericRedBlackTreeNode<TValue> currentNode, GenericRedBlackTreeNode<TValue> parentNode)
		{
			while (IsBlack(currentNode) && currentNode != _root)
			{
				if (IsLeftChild(currentNode))
				{
					FixRemoveForLeftChild(ref currentNode, parentNode);
				}
				else
				{
					FixRemoveForRightChild(ref currentNode, parentNode);
				}
			}

			if (currentNode != null)
				currentNode.IsRed = false;
		}

		/// <summary>
		/// Fixes the Red-Black Tree for a left child during a remove operation.
		/// </summary>
		/// <param name="currentNode">The node to fix.</param>
		/// <param name="parentNode">The parentNode of the node.</param>
		private void FixRemoveForLeftChild(ref GenericRedBlackTreeNode<TValue> currentNode, GenericRedBlackTreeNode<TValue> parentNode)
		{
			var sibling = GetRightSibling(currentNode);

			if (IsRed(sibling))
			{
				// Case 1: Recoloring
				RecolorNodes(sibling, parentNode);
				RotateLeft(parentNode);
				sibling = GetRightSibling(currentNode.Parent as GenericRedBlackTreeNode<TValue>);
			}

			FixRemoveCasesForLeftChild(ref currentNode, parentNode, sibling);
		}

		/// <summary>
		/// Handles various cases for a left child during a remove operation.
		/// </summary>
		/// <param name="currentNode">The node to fix.</param>
		/// <param name="parentNode">The parentNode of the node.</param>
		/// <param name="sibling">The sibling of the node.</param>
		private void FixRemoveCasesForLeftChild(ref GenericRedBlackTreeNode<TValue> currentNode, GenericRedBlackTreeNode<TValue> parentNode, GenericRedBlackTreeNode<TValue> sibling)
		{
			if (IsBlack(sibling.Left as GenericRedBlackTreeNode<TValue>) && IsBlack(sibling.Right as GenericRedBlackTreeNode<TValue>))
			{
				// Case 2: Recoloring
				sibling.IsRed = true;
				currentNode = parentNode;
			}
			else
			{
				if (IsBlack(sibling.Right as GenericRedBlackTreeNode<TValue>))
				{
					// Case 3: Right rotation
					RecolorNodes(sibling, sibling.Left as GenericRedBlackTreeNode<TValue>);
					RotateRight(sibling);
					sibling = GetRightSibling(parentNode);
				}

				// Case 4: Recoloring
				RecolorNodes(parentNode, sibling, sibling.Right as GenericRedBlackTreeNode<TValue>);
				RotateLeft(parentNode);
				currentNode = _root;
			}
		}

		/// <summary>
		/// Fixes the Red-Black Tree for a right child during a remove operation.
		/// </summary>
		/// <param name="currentNode">The node to fix.</param>
		/// <param name="parentNode">The parentNode of the node.</param>
		private void FixRemoveForRightChild(ref GenericRedBlackTreeNode<TValue> currentNode, GenericRedBlackTreeNode<TValue> parentNode)
		{
			var sibling = GetLeftSibling(currentNode);

			if (IsRed(sibling))
			{
				// Case 1: Recoloring
				RecolorNodes(sibling, parentNode);
				RotateRight(parentNode);
				sibling = GetLeftSibling(currentNode.Parent as GenericRedBlackTreeNode<TValue>);
			}

			FixRemoveCasesForRightChild(ref currentNode, parentNode, sibling);
		}

		/// <summary>
		/// Handles various cases for a right child during a remove operation.
		/// </summary>
		/// <param name="currentNode">The node to fix.</param>
		/// <param name="parentNode">The parentNode of the node.</param>
		/// <param name="sibling">The sibling of the node.</param>
		private void FixRemoveCasesForRightChild(ref GenericRedBlackTreeNode<TValue> currentNode, GenericRedBlackTreeNode<TValue> parentNode, GenericRedBlackTreeNode<TValue> sibling)
		{
			if (IsBlack(sibling.Left as GenericRedBlackTreeNode<TValue>) && IsBlack(sibling.Right as GenericRedBlackTreeNode<TValue>))
			{
				// Case 2: Recoloring
				sibling.IsRed = true;
				currentNode = parentNode;
			}
			else
			{
				if (IsBlack(sibling.Left as GenericRedBlackTreeNode<TValue>))
				{
					// Case 3: Left rotation
					RecolorNodes(sibling, sibling.Right as GenericRedBlackTreeNode<TValue>);
					RotateLeft(sibling);
					sibling = GetLeftSibling(parentNode);
				}

				// Case 4: Recoloring
				RecolorNodes(parentNode, sibling, sibling.Left as GenericRedBlackTreeNode<TValue>);
				RotateRight(parentNode);
				currentNode = _root;
			}
		}

		/// <summary>
		/// Checks if a given node is black.
		/// </summary>
		/// <param name="currentNode">The node to check.</param>
		/// <returns>True if the node is black; otherwise, false.</returns>
		private static bool IsBlack(GenericRedBlackTreeNode<TValue> currentNode) => currentNode == null || !currentNode.IsRed;

		/// <summary>
		/// Rotates the tree to the left, preserving the Red-Black Tree properties.
		/// </summary>
		/// <param name="leftNode">The node to rotate.</param>
		private void RotateLeft(GenericRedBlackTreeNode<TValue> leftNode)
		{
			GenericRedBlackTreeNode<TValue> rightNode = (GenericRedBlackTreeNode<TValue>)leftNode.Right;
			leftNode.Right = rightNode.Left;

			if (rightNode.Left != null)
				rightNode.Left.Parent = leftNode;

			rightNode.Parent = leftNode.Parent;

			if (leftNode.Parent == null)
				_root = rightNode;
			else if (leftNode == leftNode.Parent.Left)
				leftNode.Parent.Left = rightNode;
			else
				leftNode.Parent.Right = rightNode;

			rightNode.Left = leftNode;
			leftNode.Parent = rightNode;
		}

		/// <summary>
		/// Rotates the tree to the right, preserving the Red-Black Tree properties.
		/// </summary>
		/// <param name="rightNode">The node to rotate.</param>
		private void RotateRight(GenericRedBlackTreeNode<TValue> rightNode)
		{
			GenericRedBlackTreeNode<TValue> leftNode = (GenericRedBlackTreeNode<TValue>)rightNode.Left;
			rightNode.Left = leftNode.Right;

			if (leftNode.Right != null)
				leftNode.Right.Parent = rightNode;

			leftNode.Parent = rightNode.Parent;

			if (rightNode.Parent == null)
				_root = leftNode;
			else if (rightNode == rightNode.Parent.Left)
				rightNode.Parent.Left = leftNode;
			else
				rightNode.Parent.Right = leftNode;

			leftNode.Right = rightNode;
			rightNode.Parent = leftNode;
		}

		/// <summary>
		/// Gets or sets the value associated with the specified key in the Red-Black Tree.
		/// </summary>
		/// <param name="key">The key to access or modify.</param>
		/// <returns>The value associated with the key.</returns>
		public TValue this[int key]
		{
			get
			{
				var node = FindNodeContainingKey(_root, key);
				if (node == null)
				{
					return default;
				}
				return node.Value;
			}
			set
			{
				var node = FindNodeContainingKey(_root, key);
				if (node.Key == key)
				{
					node.Value = value;
				}
			}
		}

		/// <summary>
		/// Returns an enumerator that iterates through the elements of the Red-Black Tree in an in-order traversal.
		/// </summary>
		/// <returns>An enumerator that can be used to iterate through the elements of the Red-Black Tree in an in-order traversal.</returns>
		public IEnumerator<KeyValuePair<int, TValue>> GetEnumerator()
		{
			var queue = GenericFactoryPool.Create(() => new Queue<GenericRedBlackTreeNode<TValue>>());
			GenericFactoryPool.SetPoolResetAction<Queue<GenericRedBlackTreeNode<TValue>>>((queue) => queue.Clear());
			queue.Enqueue(_root);

			while (queue.Count > 0)
			{
				var currentNode = queue.Dequeue();

				if (currentNode.Left != null) queue.Enqueue(currentNode.Left as GenericRedBlackTreeNode<TValue>);
				if (currentNode.Right != null) queue.Enqueue(currentNode.Right as GenericRedBlackTreeNode<TValue>);

				yield return new KeyValuePair<int, TValue>(currentNode.Key, currentNode.Value);
			}

			GenericFactoryPool.Recycle(queue);
		}

		/// <summary>
		/// Returns all elements of the Red-Black Tree.
		/// </summary>
		/// <returns>An enumerable of all key-value pairs.</returns>
		public IEnumerable<KeyValuePair<int, TValue>> GetAll()
		{
			var queue = GenericFactoryPool.Create(() => new Queue<GenericRedBlackTreeNode<TValue>>());
			GenericFactoryPool.SetPoolResetAction<Queue<GenericRedBlackTreeNode<TValue>>>((queue) => queue.Clear());
			queue.Enqueue(_root);

			while (queue.Count > 0)
			{
				var currentNode = queue.Dequeue();

				if (currentNode.Left != null) queue.Enqueue(currentNode.Left as GenericRedBlackTreeNode<TValue>);
				if (currentNode.Right != null) queue.Enqueue(currentNode.Right as GenericRedBlackTreeNode<TValue>);

				yield return new KeyValuePair<int, TValue>(currentNode.Key, currentNode.Value);

				GenericFactoryPool.Recycle(currentNode);
			}

			GenericFactoryPool.Recycle(queue);
		}

		/// <summary>
		/// Provides a way to get all items in the tree that correspond with the provided HashSet of Keys.
		/// </summary>
		/// <param name="list">The HasSet containing the keys to return.</param>
		/// <returns>an IEnumerable collection of KeyValuePair items.</returns>
		public IEnumerable<KeyValuePair<int, TValue>> GetList(List<int> list)
		{
			var queue = GenericFactoryPool.Create(() => new Queue<GenericRedBlackTreeNode<TValue>>());
			GenericFactoryPool.SetPoolResetAction<Queue<GenericRedBlackTreeNode<TValue>>>((queue) => queue.Clear());
			queue.Enqueue(_root);

			while (queue.Count > 0)
			{
				var currentNode = queue.Dequeue();

				if (currentNode.Left != null) queue.Enqueue(currentNode.Left as GenericRedBlackTreeNode<TValue>);
				if (currentNode.Right != null) queue.Enqueue(currentNode.Right as GenericRedBlackTreeNode<TValue>);

				if (list.Remove(currentNode.Key))
				{
					yield return new KeyValuePair<int, TValue>(currentNode.Key, currentNode.Value);
				}
				GenericFactoryPool.Recycle(currentNode);

			}
			GenericFactoryPool.Recycle(queue);
		}

		/// <summary>
		/// Performs bulk insertion of key-value pairs into the Red-Black Tree.
		/// </summary>
		/// <param name="keyValuePairs">The key-value pairs to insert.</param>
		public void BulkInsert(IEnumerable<KeyValuePair<int, TValue>> keyValuePairs)
		{
			ArgumentNullException.ThrowIfNull(keyValuePairs);
			if (_index.Count + keyValuePairs.Count() > _maxSize && _maxSize > 0) throw new InvalidOperationException($"The maximum size of {_maxSize} has been reached or exceeded. This bulk insert requires {_index.Count + keyValuePairs.Count()} total spaces.");

			// Convert the collection to an array for easier indexing
			var pairsArray = keyValuePairs.ToArray();

			// Ensure the array is not empty
			if (pairsArray.Length == 0)
			{
				return;
			}

			// Sort the array by keys to ensure balanced insertion
			Array.Sort(pairsArray, (x, y) => x.Key.CompareTo(y.Key));

			// Build the Red-Black Tree from the sorted array
			_root = BuildTreeFromArray(pairsArray, 0, pairsArray.Length - 1, null);

			// Rebalance the tree after bulk insertion
			FixInsert(ref _root);
		}

		/// <summary>
		/// Builds a Red-Black Tree from an array of key-value pairs.
		/// </summary>
		/// <param name="pairsArray">The array of KeyValuePairs to build the tree with.</param>
		/// <param name="start">The position to start adding items from..</param>
		/// <param name="end">The position to stop adding items at.</param>
		/// <param name="parentNode">The node where the tree is merged.</param>
		/// <returns>the newly formed tree at a node to add into a Tree.</returns>
		private static GenericRedBlackTreeNode<TValue> BuildTreeFromArray(KeyValuePair<int, TValue>[] pairsArray, int start, int end, GenericRedBlackTreeNode<TValue> parentNode)
		{
			if (start > end)
			{
				return null;
			}

			int mid = (start + end) / 2;

			var nodeToInsert = GenericFactoryPool.Create(() => new GenericRedBlackTreeNode<TValue>(pairsArray[mid].Key, pairsArray[mid].Value));
			nodeToInsert.Parent = parentNode;

			// Recursively build the left and right subtrees
			nodeToInsert.Left = BuildTreeFromArray(pairsArray, start, mid - 1, nodeToInsert);
			nodeToInsert.Right = BuildTreeFromArray(pairsArray, mid + 1, end, nodeToInsert);

			return nodeToInsert;
		}

		/// <summary>
		/// Resets the state of the Red-Black Tree, effectively clearing it and resetting any configuration options.
		/// </summary>
		public void ResetState()
		{
			_root = null;
			_index = null;

			GenericFactoryPool.Recycle(_index);
			GenericFactoryPool.Recycle(_root);

			_index = GenericFactoryPool.Create(() => new HashSet<int>());
			_maxSize = default;
		}
	}
}

namespace RedBlackTree.Nodes
{

	/// <summary>
	/// Represents a node in a generic Red-Black Tree used to store key-value pairs.
	/// This class supports operations for managing the node's key, value, color, and child nodes.
	/// </summary>
	/// <typeparam name="TValue">The type of value associated with the node.</typeparam>
	public class GenericRedBlackTreeNode<TValue> : IGenericRedBlackNode<int, TValue>
	{
		/// <summary>
		/// An integer value used as an identifier for the KeyValuePair. 
		/// Must be unique.
		/// </summary>
		public int Key { get; set; }

		/// <summary>
		/// This is the Generic Value type.
		/// </summary>
		public TValue Value { get; set; }

		/// <summary>e	--';P
		/// Represents a node in a generic Red-Black Tree used to store key-value pairs.
		/// This class supports operations for managing the node's key, value, color, and child nodes.
		/// </summary>
		/// <param name="key"></param>
		/// <param name="value"></param>
		public GenericRedBlackTreeNode(int key, TValue value)
		{
			Key = key;
			Value = value;
		}

		/// <summary>
		/// Gets or sets a value indicating whether the node is red in the Red-Black Tree.
		/// </summary>
		public bool IsRed { get; set; } = true;

		/// <summary>
		/// Checks if the node is empty (has no key).
		/// </summary>
		public bool IsEmpty() => Key == default;

		/// <summary>
		/// Gets or sets the parentNode node of the current node.
		/// </summary>
		public IGenericRedBlackNode<int, TValue> Parent { get; set; }

		/// <summary>
		/// Gets or sets the left child node of the current node.
		/// </summary>
		public IGenericRedBlackNode<int, TValue> Left { get; set; }

		/// <summary>
		/// Gets or sets the right child node of the current node.
		/// </summary>
		public IGenericRedBlackNode<int, TValue> Right { get; set; }

		/// <summary>
		/// Resets the internal state of the node to its default values, making it available for reuse.
		/// </summary>
		public void ResetState()
		{
			Key = 0;
			Value = default;

			IsRed = true;

			Parent = null;
			Left = null;
			Right = null;
		}

		/// <summary>
		/// Determines whether the specified object is equal to this object 
		/// </summary>
		/// <param name="obj">The object to compare this object with.</param>
		/// <returns>true is it is equal, and false if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj == null || GetType() != obj.GetType())
				return false;

			var other = (GenericRedBlackTreeNode<TValue>)obj;
			return Key.Equals(other.Key) && Value.Equals(other.Value);
		}

		/// <summary>
		/// Serves as the default hash function..
		/// </summary>
		/// <returns>A Hash code for the current object</returns>
		public override int GetHashCode()
		{
			return HashCode.Combine(Key, Value);
		}
	}

}

Summary:
The GenericRedBlackTree class is a Red-Black Tree implementation in C# that supports a generic value type and uses an integer as the key. It provides methods for inserting, removing, updating, and retrieving key-value pairs in the tree. The tree maintains the Red-Black Tree properties to ensure balanced and efficient operations.

Bug:
I did not find any bugs in the code.

Code Style:
The code follows a consistent and readable style. The naming conventions are clear and descriptive, making it easy to understand the purpose of each variable and method. The code also uses proper indentation and spacing, enhancing readability.

Code Structure:
The code is well-structured, with clear separation of concerns. The GenericRedBlackTree class handles the overall tree structure and operations, while the GenericRedBlackTreeNode class represents individual nodes in the tree. This separation allows for better organization and maintainability of the code.

Readability:
The code is highly readable and easy to understand. The use of meaningful variable and method names, along with comments, helps to clarify the purpose and functionality of each component. The code also follows consistent formatting and indentation, further enhancing readability.

Performance:
The code appears to be efficient in terms of performance. The Red-Black Tree data structure provides efficient insertion, deletion, and retrieval operations with a time complexity of O(log n). The code also uses appropriate data structures, such as queues and stacks, to optimize certain operations.

Scalability:
The code is designed to handle a maximum size limit for the tree, which allows for scalability and prevents the tree from growing too large. The MaxSize property can be set to limit the number of elements in the tree. This ensures that the tree remains efficient and manageable, even with a large number of elements.

Security:
The code does not contain any security vulnerabilities. However, it is important to note that the security of the tree depends on how it is used and the data it contains. Proper access control and validation should be implemented at the application level to ensure the security of the tree and its data.

Error Handling:
The code includes appropriate error handling mechanisms. It throws exceptions in cases where invalid input or operations are detected, such as inserting a duplicate key or exceeding the maximum size limit. This helps to prevent unexpected behavior and provides clear feedback to the caller.

Conclusion:
Overall, the GenericRedBlackTree code appears to be well-written and efficient. It provides a reliable and scalable implementation of a Red-Black Tree data structure in C#. The code follows good coding practices, ensuring readability, maintainability, and performance. With proper usage and integration into an application, this code can provide efficient and balanced storage and retrieval of key-value pairs.





namespace GenericFactoryPool
{

	/// <summary>
	/// Provides a generic object pool for creating and recycling objects of various types.
	/// Object pooling helps improve performance by reusing objects instead of repeatedly
	/// creating and destroying them.The Object Pool has a max size set to 64 by default.
	/// </summary>
	/// <remarks>
	/// <br>The Following is an Example of how to use this Factory Pool.</br>
	/// <br>The Example demonstrates a Pool of a List of strings. Though you can create any type you need. </br>
	/// <br>Complete Usage Example: </br>
	/// <example> <br> </br>
	/// <br> <c>GenericFactoryPool.SetMaxCapacity(10);</c> </br>
	/// <br> <c>Func&lt;List&lt;string&gt;&gt; listFactory = () => new List&lt;string&gt;();</c> </br>
	/// <br> <c>var listPool = GenericFactoryPool.Create(listFactory);</c> </br>
	/// <br> <c>listPool.SetResetAction(list => list.Clear());</c> </br>
	/// <br> <c>GenericFactoryPool.SetPoolSize&lt;List&lt;string&gt;&gt;(10, listFactory);</c> </br>
	/// <br> <c>var myList = listPool.GetObject(listFactory);</c> </br>
	/// <br> <c>myList.Add("Item 1");</c> </br>
	/// <br> <c>myList.Add("Item 2");</c> </br>
	/// <br> <c>int count = GenericFactoryPool.GetPoolCount&lt;List&lt;string&gt;&gt;();</c> </br>
	/// <br> <c>GenericFactoryPool.Recycle(myList);</c> </br>
	/// <br> <c>GenericFactoryPool.ClearPool&lt;List&lt;string&gt;&gt;();</c> </br>
	/// </example> </remarks>
	public static class GenericFactoryPool
	{
		private static readonly ConcurrentDictionary<Type, object> _pools = new();
		private static int _maxCapacity;

		/// <summary>
		/// <br>Checks the <seealso cref="ObjectPool{T}"/> or creates an object of the specified type using a factory pattern.</br>
		/// <br>If an <seealso cref="ObjectPool{T}"/> exists for the specified type, it will be used to retrieve
		/// a recycled object; otherwise, a new <seealso cref="ObjectPool{T}"/> will be created.</br>
		/// </summary>
		/// <remarks>
		/// <br>Example Usage:</br>
		/// <example><br> </br>
		/// <br> <c>Func&lt;List&lt;string&gt;&gt; listFactory = () => new List&lt;string&gt;();</c> </br>
		/// <br> <c>var listPool = GenericFactoryPool.Create(listFactory);</c> </br>
		/// </example> </remarks>
		/// <typeparam name="T" >"The generic object type."</typeparam>
		/// <param name="factoryMethod">A function that creates and returns an object of type T. </param>
		/// <returns>An object of the specified type.</returns>
		public static T Create<T>(Func<T> factoryMethod)
		{
			ArgumentNullException.ThrowIfNull(factoryMethod);

			if (_pools.TryGetValue(typeof(T), out object pool) && pool is ObjectPool<T> objectPool)
			{
				return objectPool.GetObject(factoryMethod);
			}
			else
			{
				ObjectPool<T> newObjectPool = new();
				_ = _pools.TryAdd(typeof(T), newObjectPool);
				return newObjectPool.GetObject(factoryMethod);
			}
		}

		/// <summary>
		/// Recycles an object of the specified type back into the object pool if a pool exists.
		/// If the object implements the `IRecyclable` interface, its state is reset before recycling.
		/// </summary>
		/// <remarks>
		/// <br>Example Usage:</br>
		/// <example><br> </br>
		/// <br> <c>GenericFactoryPool.Recycle(myList);</c> </br>
		/// </example> </remarks>
		/// <typeparam name="T">The type of object to recycle.</typeparam>
		/// <param name="item">The object to recycle.</param>
		public static void Recycle<T>(T item)
		{
			ArgumentNullException.ThrowIfNull(item);

			if (_pools.TryGetValue(typeof(T), out object pool) && pool is ObjectPool<T> objectPool)
			{
				if (GetPoolCount<T>() < _maxCapacity || _maxCapacity == 0)
				{
					objectPool.ReturnObject(item);
				}
			}
		}

		/// <summary>
		/// Sets the Maximum capacity a pool can be,.
		/// The new capacity can be any positive integer including 0 which indicates no capacity limit.
		/// </summary>
		/// <remarks>
		/// <br>Example Usage:</br>
		/// <example><br> </br>
		/// <br> <c>GenericFactoryPool.SetMaxCapacity(10);</c> </br>
		/// </example> </remarks>
		/// <param name="newCapacity"></param>
		public static void SetMaxCapacity(int newCapacity)
		{
			if (newCapacity < 0)
			{
				throw new ArgumentException($"{nameof(newCapacity)} must be a positive integer.");
			}

			_maxCapacity = newCapacity;
		}

		/// <summary>
		/// Sets a custom reset action to be invoked when an object is returned to the pool.
		/// </summary>
		/// <remarks>
		/// <br>Example Usage:</br>
		/// <example><br> </br>
		/// <br> <c>listPool.SetResetAction(list => list.Clear());</c> </br>
		/// </example> </remarks>
		/// <typeparam name="T">The type of object for which to set the reset action.</typeparam>
		/// <param name="resetAction">An action to reset the state of an object when it is retrieved from the pool.</param>
		public static void SetPoolResetAction<T>(Action<T> resetAction)
		{
			ArgumentNullException.ThrowIfNull(resetAction);

			if (_pools.TryGetValue(typeof(T), out object pool) && pool is ObjectPool<T> objectPool)
			{
				objectPool.SetResetAction(resetAction);
			}
		}

		/// <summary>
		/// Clears the object pool associated with the specified type, if it exists. This operation removes all objects
		/// currently in the pool.
		/// </summary>
		/// <remarks>
		/// <br>Example Usage:</br>
		/// <example><br> </br>
		/// <br> <c>GenericFactoryPool.ClearPool&lt;List&lt;string&gt;&gt;();</c> </br>
		/// </example> </remarks>
		/// <typeparam name="T">The type for which the object pool should be cleared.</typeparam>
		public static void ClearPool<T>()
		{
			if (_pools.TryGetValue(typeof(T), out object pool) && pool is ObjectPool<T> objectPool)
			{
				objectPool.Clear();
			}
		}

		/// <summary>
		/// Retrieves the count of objects currently in the object pool associated with the specified type, if it exists.
		/// </summary>
		/// <remarks>
		/// <br>Example Usage:</br>
		/// <example><br> </br>
		/// <br> <c>int count = GenericFactoryPool.GetPoolCount&lt;List&lt;string&gt;&gt;();</c> </br>
		/// </example> </remarks>
		/// <typeparam name="T">The type for which to retrieve the object pool count.</typeparam>
		/// <returns>The number of objects currently in the object pool, or 0 if the pool does not exist.</returns>
		public static int GetPoolCount<T>()
		{
			return _pools.TryGetValue(typeof(T), out object pool) && pool is ObjectPool<T> objectPool ? objectPool.Count : 0;
		}

		/// <summary>
		/// Sets the size of the object pool associated with the specified type and specifies a factory method for creating new objects
		/// when the pool needs to be expanded. The size argument needs to be a positive integer no larger than the max capacity. 
		/// </summary>
		/// <remarks>
		/// <br>Example Usage:</br>
		/// <example><br> </br>
		/// <br> <c>GenericFactoryPool.SetPoolSize&lt;List&lt;string&gt;&gt;(10, listFactory);</c> </br>
		/// </example> </remarks>
		/// <typeparam name="T">The type for which to set the object pool size.</typeparam>
		/// <param name="size">The desired size of the object pool.</param>
		/// <param name="factoryMethod">A delegate that creates new instances of type T when needed.</param>
		public static void SetPoolSize<T>(int size, Func<T> factoryMethod)
		{
			ArgumentNullException.ThrowIfNull(factoryMethod);
			if (size > _maxCapacity && _maxCapacity > 0)
			{
				throw new ArgumentException($"{nameof(size)} cannot exceed the max capacity set by {nameof(_maxCapacity)} while a max capacity is set. ");
			}

			if (_pools.TryGetValue(typeof(T), out object pool) && pool is ObjectPool<T> objectPool)
			{
				objectPool.SetSize(size, factoryMethod);
			}
		}

		/// <summary>
		/// Prepopulates the object pool associated with the specified type with a specified number of objects, using the provided factory method.
		/// </summary>
		/// <remarks>
		/// <br>Example Usage:</br>
		/// <example><br> </br>
		/// <br> <c>GenericFactoryPool.PrepopulatePool&lt;List&lt;string&gt;&gt;(5, listFactory);</c> </br>
		/// </example> </remarks>
		/// <typeparam name="T">The type for which to prepopulate the object pool.</typeparam>
		/// <param name="count">The number of objects to prepopulate the pool with.</param>
		/// <param name="factoryMethod">A delegate that creates new instances of type T for prepopulating the pool.</param>
		public static void PrepopulatePool<T>(int count, Func<T> factoryMethod)
		{
			ArgumentNullException.ThrowIfNull(factoryMethod);
			if (count > _maxCapacity && _maxCapacity > 0)
			{
				throw new ArgumentException($"{nameof(count)} cannot exceed the max capacity set by {nameof(_maxCapacity)} while a max capacity is set. ");
			}

			if (_pools.TryGetValue(typeof(T), out object pool) && pool is ObjectPool<T> objectPool)
			{
				objectPool.Prepopulate(count, factoryMethod);
			}
		}

		/// <summary>
		/// An Ordered object pool of the specified type <typeparamref name="T"/>, used by the Generic Factory Pool to store object types.
		/// Not for outside use. 
		/// </summary>
		/// <typeparam name="T">The type of object this pool holds.</typeparam>
		private sealed class ObjectPool<T>
		{
			/// <summary>
			/// The pool will hold the items ready to be used.
			/// if no items are available one will be made.
			/// all returned items will be added to the pool if the max size has not been reached.
			/// </summary>
			private readonly ConcurrentBag<T> _pool = new();

			/// <summary>
			/// The ResetAction allow for a custom reset action to be invoked when an item is returned. 
			/// </summary>
			private Action<T> _resetAction;

			/// <summary>
			/// Gets an object from the pool, either by reusing a recycled object or by creating a new one.
			/// </summary>
			/// <param name="factoryMethod">A function that creates and returns an object of type T.</param>
			/// <returns>An object of type T from the pool.</returns>
			internal T GetObject(Func<T> factoryMethod)
			{
				return _pool.TryTake(out T pooledItem) ? pooledItem : factoryMethod();
			}

			/// <summary>
			/// Returns an object back to the pool for potential reuse.
			/// If the object implements the `IRecyclable` interface, its state is reset before recycling.
			/// </summary>
			/// <param name="item">The object to return to the pool.</param>
			internal void ReturnObject(T item)
			{
				if (item is IRecyclable recyclable)
				{
					recyclable.ResetState();
				}

				_resetAction?.Invoke(item); // Invoke the reset action if set
				_pool.Add(item);
			}

			/// <summary>
			/// Clears all objects from the object pool by dequeuing them until the pool is empty.
			/// </summary>
			internal void Clear()
			{
				_pool.Clear();
				while (!_pool.IsEmpty && _pool.TryTake(out _)) { }
			}

			/// <summary>
			/// Gets the current count of objects in the object pool.
			/// </summary>
			internal int Count => _pool.Count;

			/// <summary>
			/// Sets the size of the object pool, adjusting it to the specified size while using the provided factory method
			/// to create new objects as needed or removing excess objects.
			/// </summary>
			/// <param name="size">The desired size of the object pool.</param>
			/// <param name="factoryMethod">A delegate that creates new instances of type T when needed.</param>
			internal void SetSize(int size, Func<T> factoryMethod)
			{
				while (_pool.Count > size && _pool.TryTake(out _)) { }

				while (_pool.Count < size)
				{
					_pool.Add(factoryMethod());
				}
			}

			/// <summary>
			/// Prepopulates the object pool with a specified number of objects, using the provided factory method.
			/// </summary>
			/// <param name="count">The number of objects to prepopulate the pool with.</param>
			/// <param name="factoryMethod">A delegate that creates new instances of type T for prepopulating the pool.</param>
			internal void Prepopulate(int count, Func<T> factoryMethod)
			{
				for (int i = 0; i < count; i++)
				{
					_pool.Add(factoryMethod());
				}
			}

			/// <summary>
			/// Sets a custom reset action to be invoked when an object is returned to the pool.
			/// </summary>
			/// <param name="resetAction">An action to reset the state of an object when it is retrieved from the pool.</param>
			internal void SetResetAction(Action<T> resetAction)
			{
				_resetAction = resetAction;
			}

		}
	}
}
